% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OT_joint.r
\name{OT_joint}
\alias{OT_joint}
\alias{OT_JOINT}
\alias{ot_joint}
\title{OT_joint()}
\usage{
OT_joint(datab, index_DB_Y_Z = 1:3, nominal = NULL, ordinal = NULL,
  logic = NULL, prep_choice = "E", infoFAMD = 80, percent_c = 1,
  maxrelax = 0, lambda_reg = 0, norm = 1, prox_dist = 1,
  aggregate_tol = 1, which.DB = 3)
}
\arguments{
\item{datab}{A data.frame that must have at least 4 columns sorted in a non-specific order. One column must be a key column of 2 classes for the databases identification, where the names of the two databases
must be alphanumerically ranked in ascending order (By examples: 1 for the top database and 2 for the database from below, or more logically here A and B  ...But NOT B and A!).One column (Y here but other names are allowed)
must correspond to the target variable related to the information of interest to merge with its specific encoding in the database A (corresponding encoding should be so missing in the database B). In the same way,
one column (Z here) corresponds to the target variable that summarizes the same information as Y but with its specific encoding in the database B (corresponding encoding should be so missing in the database A).
Finally, your database must have at least one covariate with same encoding in A and B. Please not that, if your data.frame has only 4 columns, that is to say, only one covariate, if this latter has NA, and unless user
has previously imputed the corresponding missing information,the OT algorithm will only run with complete cases.}

\item{index_DB_Y_Z}{A vector of exactly 3 integers. The 1st integer must correspond to the index of the databases identification column (DB identifier). The 2nd integer corresponds
to the index of the target variable in the 1st database (A) while the 3rd integer corresponds to the index of column related to the target variable in the 2nd database (B).}

\item{nominal}{A vector of integers that corresponds to the indexes of columns of all the nominal (not ordered) variables (DB identification and target variables included if it is the case for them).}

\item{ordinal}{A vector of integers that corresponds to the indexes of columns of all the ordinal variables (DB identification and target variables included if it is the case for them).}

\item{logic}{A vector of integers that corresponds to the indexes of columns of all the boolean variables of the data.frame.}

\item{prep_choice}{A character (with quotes) corresponding to the distance function chosen between: The euclidean distance ("E", by default), The Manhattan distance ("M"),
the Gower distance ("G"), and the Hamming distance ("H") for binaries covariates only.}

\item{infoFAMD}{A percent value (between 0 and 100) that corresponds to the part of variability taken into account by the principal components of the FAMD when this option is required.}

\item{percent_c}{Percent of closest neighbors taken in the computation of the cost matrix.}

\item{maxrelax}{Maximum percentage of deviation from expected probability masses. It must be equal to 0 (default value) for the JOINT model, and equal to a strictly positive value for the R-JOINT model}

\item{lambda_reg}{A coefficient measuring the importance of the regularization term. In the related reference, it corresponds to the R-JOINT model for a vue other than 0 (Default value))}

\item{norm}{A decimal number to choose between 0 and 1. This value specifies the distance function chosen to compute the neighbors of the covariates for regularization. Equals to 0 for the Hamming distance, to 1 for the Manhattan distance and to 2 for the Euclidean distance respectively}

\item{prox_dist}{A value between 0 and 1 that corresponds to a threshold (0.1 by default) below which an individual is considered significantly close (neighbor) to a given profile of covariates.}

\item{aggregate_tol}{A value between 0 and 1 that quantify how much individuals' covariates must be closed for aggregation}

\item{which.DB}{A value equals to 1 if the user only wants to impute Z in the 1st database (A), equals to 2 if the user only wants to impute Y in the 2nd database (B) or equals 3 for imputation of Y in Z in the both databases (A and B)}
}
\value{
A list of 7 elements containing:
    \item{TIME_EXE}{Running time of the function}
    \item{GAMMA_A}{Cost matrix corresponding to an estimation (gamma, see reference for more details) to the joint distribution of (YA,ZA)}
    \item{GAMMA_B}{Cost matrix corresponding to an estimation to the joint distribution of (YB,ZB)}
    \item{profile}{A data.frame that gives all details about the remaining P profiles of covariates. These informations can be linked to the \code{estimatorZA} and the \code{estimatorYB} objects for a better interpretation of the results}
    \item{estimatorZA}{Estimates of the probability distribution of Z conditional to X and Y in database A from predictions stored in an array. The number of rows of each table corresponds to the total number of profiles of covariates.
    The number of columns of each table corresponds to the number of levels of Y. The row names of each table corresponds to the values of the covariates sorted by order of appearance in the merged database. The third element of the array is the possible level of Z.}
    \item{estimatorYB}{Estimates of the probability distribution of Y conditional to X and Z in database B from predictions stored in an array. The number of rows of each table corresponds to the total number of profiles of covariates.
    The number of columns of each table corresponds to the number of levels of Z. The row names of each table corresponds to the values of the covariates sorted by order of appearance in the merged database. The third element of the array is the possible level of Y.}
    \item{DATA1_OT}{database A with imputed individual prediction on Z using OT}
    \item{DATA2_OT}{database B with imputed individual prediction on Y using OT}
}
\description{
Implementation of the Optimal Transportation (OT) algorithm for data integration by directly estimating the joint distributions (Y,Z,X) in the two databases
}
\details{
The context of use of this function is the same as for the \code{\link{OT}} function.Nevertheless, the algorithm related to the \code{OT_joint} function does not allowed the use of continuous quantitative covariates.
Bbe sure that continuous quantitatives covariates have been deleted from your analyses or discretize beforehand using this function.

Assuming that:

\enumerate{
\item Y and Z summarize a same information of interest encoded in two distinct forms stored in two independent databases A and B (no individuals or rows in common),
\item The two databases have a set of common covariates X (i.e the same variables stored in the same forms in the two bases),
\item You would like to merge vertically A and B keeping this variable of interest in at least one of its two encodings.
}

So, this function gives you a possible answer to this recoding problem by using the Optimal Transportation Theory.
The models implemented in this function correspond to the JOINT and R-JOINT models described in the referenced article 2.

The algorithm linked to this function transports the joint distributions of target variables AND covariates (X,Y,Z) while the \code{\link{OT}} function only derives the joint distribution of Y and Z.
By direclty solving the recoding problem (given the individual predictions of Z in A and Y in B), an independent post-treatment step like the nearest neighbor procedure implemented in the \code{\link{OT}} function is no longer required,
and the individual predictions of Z in A and Y in B are given at once.

As for the \code{\link{OT}} function, this function allows to relax the constraints on marginal distributions (using the \code{maxrelax} option) and gives the possibility to add an L^1 regularization term (using the \code{lambda_reg} option) expressing that the transportation map should not vary too quickly
with respect to X.

For more details, please consult the reference article 2.
}
\examples{

### Using the \\code{simu_data} object
### Y and Z are a same variable encoded in 2 different forms in DB A and B:
### (3 levels for Y and 5 levels for Z)
#--------
data(simu_data)

### using a sample of the tab_test object (3 complete covariates)
### Y1 and Y2 are a same variable encoded in 2 different forms in DB 1 and 2:
### (4 levels for Y1 and 3 levels for Y2)

data(tab_test)
# Example with n1 = n2 = 75 and only X1 and X2 as covariates
tab_test2 = tab_test[c(1:75,5001:5075),1:5]

### An example of JOINT model (Manhattan distance)
# Suppose we want to impute the missing parts of Y1 in DB2 only ...
try1J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3),
                 prep_choice = "M", norm = 1, which.DB = 2)

\dontrun{
### An example of R-JOINT model (Gower distance) by including a term of error
### in the constraints on the marginals (relaxation)
# Suppose we want to impute the missing parts of Y2 in DB1 only ...
try2J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3,6),
                 prep_choice = "G", maxrelax = 0.4, norm = 3, which.DB = 1)

### An example of R-JOINT model (Euclidean distance) with relaxation and regularization terms
try3J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3,6),
                 prep_choice = "E", maxrelax = 0.4, lambda_reg = 0.9, norm = 2, which.DB = 3)


### Using the \\code{simu_data} object
### Y and Z are a same variable encoded in 2 different forms in DB A and B:
### (3 levels for Y and 5 levels for Z)
#--------
data(simu_data)

# By only keeping 3 covariates: Gender, Smoking and Age in a qualitative form:
simu_data2 = simu_data[c(1:100,401:500),c(1:4,7:8)]

# The variable Age has to be discretized previously:
simu_data2$Age_class = cut(simu_data2$Age,breaks = c(34,47,53,66))
simu_data2           = simu_data2[,-(ncol(simu_data2)-1)]

try4J      = OT_joint(simu_data2, nominal = c(1,4:5), ordinal = c(2:3,6),
                      prep_choice = "E", norm = 2, which.DB = 1)

# Complete Case study and only one remaining covariate:
# (Manhattan distance, DB 2 only)
simu_data3 = na.omit(simu_data2[,c(1:3,6)])
try5J      = OT_joint(simu_data3, nominal = 1, ordinal = 2:4,
                      prep_choice = "M", norm = 2, which.DB = 2)

# (Hamming distance, DB2 only)
try6J      = OT_joint(simu_data3, nominal = 1, ordinal = 2:4,
                      prep_choice = "H", norm = 0, which.DB = 2)

}
}
\references{
# Article 1:
Gares V, Dimeglio C, Guernec G, Fantin F, Lepage B, Korosok MR, savy N (2019). On the use of optimal transportation theory to recode variables and application to database merging. The International Journal of Biostatistics.
0, 20180106 (2019) | \url{https://doi.org/10.1515/ijb-2018-0106}

# Article 2:
Gares V, Omer J. Regularized optimal transport of covariates and outcomes in datarecoding(2019).hal-02123109 \url{https://hal.archives-ouvertes.fr/hal-02123109/document}
}
\seealso{
\code{\link{OT}},\code{\link{proxim_dist}}, \code{\link{avg_dist_closest}}, \code{\link{indiv_grp_closest}}, \code{\link{indiv_grp_optimal}}
}
\author{
Gregory Guernec, Valerie Gares, Jeremy Omer
\email{gregory.guernec@inserm.fr}
}
