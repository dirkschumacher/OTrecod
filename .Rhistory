stc_sum2 = vector(length = nbX)
for (i in 1:nbX){
stc_sum2[i] = ifelse(length(indXB[[i]])==0,1/length(Z),length(indXB[[i]][inst$Zobserv[indXB[[i]]+nA] == z])/ length(indXB[[i]]))*length(indXA[[i]])/nA
}
b2[z]= sum(stc_sum2)
}
b2   = b2/sum(b2)
result <-  MIPModel() %>%
ompr::add_variable(transportA[y,z],y = Y, z = Z, type = "continuous",lb=0) %>%
ompr::add_variable(deviationB[z]  ,       z = Z, type = "continuous") %>%
ompr::add_variable(absdevB[z]     ,       z = Z, type = "continuous",lb=0) %>%
ompr::set_objective(sum_expr(C[y,z]*transportA[y,z],y = Y,z=Z) , "min") %>%
ompr::add_constraint(sum_expr(transportA[y,z], z = Z) == freqY[y], y =Y) %>%
ompr::add_constraint(sum_expr(transportA[y,z],y = Y) - deviationB[z] == b2[z], z = Z) %>%
ompr::add_constraint(sum_expr(deviationB[z],z = Z)== 0) %>%
ompr::add_constraint(deviationB[z]<= absdevB[z], z = Z) %>%
ompr::add_constraint(deviationB[z]>= -absdevB[z], z = Z) %>%
ompr::add_constraint(sum_expr(absdevB[z],z=Z)<= maxrelax/2.0) %>%
ompr::solve_model(with_ROI(solver = "glpk"))
solution       = ompr::get_solution(result, transportA[y,z])
transportA_val = matrix(solution$value, length(Y),length(Z))
b1 = numeric(length(Y))
for (y in Y){
stc_sum2 = vector(length = nbX)
for (i in 1:nbX){
stc_sum2[i] = ifelse(length(indXA[[i]])==0,1/length(Y),length(indXA[[i]][inst$Yobserv[indXA[[i]]] == y])/ length(indXA[[i]]))*length(indXB[[i]])/nB
}
b1[y]= sum(stc_sum2)}
b1   = b1/sum(b1)
result <-  MIPModel() %>%
ompr::add_variable(transportB[y,z],y = Y, z= Z, type = "continuous",lb=0) %>%
ompr::add_variable(deviationA[y]  , y = Y     , type = "continuous") %>%
ompr::add_variable(absdevA[y]     , y = Y     , type = "continuous",lb=0) %>%
ompr::set_objective(sum_expr(C[y,z]*transportB[y,z],y = Y,z=Z) , "min") %>%
ompr::add_constraint(sum_expr(transportB[y,z], z = Z) - deviationA[y] == b1[y], y =Y) %>%
ompr::add_constraint(sum_expr(transportB[y,z],y = Y) == freqZ[z], z = Z) %>%
ompr::add_constraint(sum_expr(deviationA[y],y = Y)== 0) %>%
ompr::add_constraint(deviationA[y] <= absdevA[y],y =Y) %>%
ompr::add_constraint(deviationA[y] >= -absdevA[y],y =Y) %>%
ompr::add_constraint(sum_expr(absdevA[y],y = Y)<= maxrelax/2.0) %>%
ompr::solve_model(with_ROI(solver = "glpk"))
solution       = ompr::get_solution(result, transportB[y,z])
transportB_val = matrix(solution$value, length(Y),length(Z))
}
####
# Get the individual transport from the group transport
if (indiv_method == "sequential"){
YApred = indiv_grp_closest(inst, transportA_val, transportB_val, percent_closest = percent_c)$YAtrans
YBpred = indiv_grp_closest(inst, transportA_val, transportB_val, percent_closest = percent_c)$ZBtrans
} else if (indiv_method == "optimal"){
YApred = indiv_grp_optimal(inst, transportA_val, transportB_val, percent_closest = percent_c)$YAtrans
YBpred = indiv_grp_optimal(inst, transportA_val, transportB_val, percent_closest = percent_c)$ZBtrans
}
# Compute the estimated probability distributions from predictions
indXA = inst$indXA; indXB = inst$indXB;
nbX = length(indXA);
estimatorZA = array(rep(0,nbX*length(Y)*length(Z)),dim = c(nbX,length(Y),length(Z)))
# estimatorYB = estimatorZA
estimatorYB = array(rep(0,nbX*length(Y)*length(Z)),dim = c(nbX,length(Z),length(Y)))
for (x in 1:nbX){
for (i in indXA[[x]]){
estimatorZA[x,inst$Yobserv[i],YBpred[i]] = estimatorZA[x,inst$Yobserv[i],YBpred[i]] +  1/sum(inst$Yobserv[indXA[[x]]] == inst$Yobserv[i])
}
for (y in Y){
if (sum(inst$Yobserv[indXA[[x]]] == y) == 0){
estimatorZA[x,y,] = 1/length(Z)*rep(1,length(Z))
}
}
for (i in indXB[[x]]){
# estimatorYB[x,YApred[i],inst$Zobserv[i+nA]] = estimatorYB[x,YApred[i],inst$Zobserv[i+nA]] + 1/ sum(inst$Zobserv[indXB[[x]] + nA] == inst$Zobserv[i + nA])
estimatorYB[x,inst$Zobserv[i+nA],YApred[i]] = estimatorYB[x,inst$Zobserv[i+nA],YApred[i]] + 1/ sum(inst$Zobserv[indXB[[x]] + nA] == inst$Zobserv[i + nA])
}
for (z in Z){
if (sum(inst$Zobserv[indXB[[x]]+inst$nA] == z) == 0){
# estimatorYB[x,,z] = 1/length(Y)*rep(1,length(Y))
estimatorYB[x,z,] = 1/length(Y)*rep(1,length(Y))
}
}
}
row.names(estimatorZA) = row.names(estimatorYB) = ID_prof
colnames(estimatorZA)  = as.character(levels(dataB[,2]))
colnames(estimatorYB)  = as.character(levels(dataB[,3]))
DATA1_OT         = dataB[dataB[,1] == unique(dataB[,1])[1],]
DATA1_OT$OTpred  = as.factor(plyr::mapvalues(YBpred,from = sort(unique(YBpred)), to = levels(dataB[,3])[sort(unique(YBpred))]))
if (is.ordered(dataB[,3])){
DATA1_OT$OTpred = as.ordered(DATA1_OT$OTpred)
} else {}
DATA2_OT         = dataB[dataB[,1] == unique(dataB[,1])[2],]
DATA2_OT$OTpred  = as.factor(plyr::mapvalues(YApred,from = sort(unique(YApred)), to = levels(dataB[,2])[sort(unique(YApred))]))
if (is.ordered(dataB[,2])){
DATA2_OT$OTpred = as.ordered(DATA2_OT$OTpred)
} else {}
tend = Sys.time()
return(list(TIME_EXE = difftime(tend,tstart),TRANSPORT_A = transportA_val,TRANSPORT_B = transportB_val,
profile = data.frame(ID = ID_prof,prof),estimatorZA= estimatorZA,estimatorYB = estimatorYB,DATA1_OT = DATA1_OT,DATA2_OT  = DATA2_OT))
}
try1 = OT(simu_data3, nominal = 1, ordinal = 2:4, prep_choice = "H",
percent_c = 0.90, maxrelax = 0, norm = 0,indiv_method = "sequential")
try6J      = OT_joint(simu_data3, nominal = 1, ordinal = 2:4,
prep_choice = "M", norm = 1, which.DB = 2)
mat_coord  = matrix(ncol = min(ny1,ny2))
mat_coord  = matrix(ncol = 4)
dim(mat_coord)
source("C:/Users/secr/Desktop/OTrecod/R/power_set.r")
source("C:/Users/secr/Desktop/OTrecod/R/count_pos.r")
source("C:/Users/secr/Desktop/OTrecod/R/find_coord.r")
source("C:/Users/secr/Desktop/OTrecod/R/try_group.r")
source("C:/Users/secr/Desktop/OTrecod/R/error_group.r")
Z1 = as.factor(sample(1:3,50,replace = TRUE)); length(Z1)
Z4 = as.factor(sample(c("A","B","C","D","E"),50, replace = TRUE)); length(Z4)
error_group(Z1,Z4)
Z3 = as.factor(sample(1:2,50,replace = TRUE)); length(Z3)
Z1 = as.factor(sample(1:3,50,replace = TRUE)); length(Z1)
error_group(Z3,Z1,FALSE)
summary(try1)
head(try1$DATA1_OT)
table(try1$DATA1_OT$Y)DB
table(try1$DATA1_OT$Y)
table(try1$DATA1_OT$OTpred)
cc = error_group(try1$DATA1_OT$OTpred,try1$DATA1_OT$Y)
cc
cc = error_group(try1$DATA2_OT$OTpred,try1$DATA2_OT$Z)
cc
table(try1$DATA1_OT$OTpred,try1$DATA1_OT$Y)
dim(try1$DATA1_OT)
40/96
dim(try2J$DATA1_OT)TIME_EXE
dim(try2J$DATA1_OT)
head(try2J$DATA1_OT)
table(try2J$DATA1_OT$Y)
table(try2J$DATA1_OT$OTpref)
table(try2J$DATA1_OT$OTpred)
error_group(try2J$DATA1_OT$Y,try2J$DATA1_OT$OTpred)
cc = error_group(try1J$DATA2_OT$OTpred,try1J$DATA2_OT$Z)
cc
table(Z1)
table(Z4)
table(try2J$DATA1_OT$Y)
table(try2J$DATA1_OT$OTpred)
error_group(try2J$DATA1_OT$OTpred,try2J$DATA1_OT$Y)
table(try2J$DATA1_OT$OTpred,try2J$DATA1_OT$Y)
table(try1J$DATA2_OT$Z,try2J$DATA2_OT$OTpred)
table(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
error_group(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
20+9+3+16+7+20
(29+16+20)/75
1-(29+16+20)/75
levels(1:3)
head(tab_test)
summary(tab_test)
try1J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3),
prep_choice = "M", norm = 1, which.DB = 2)
error_group(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
table(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
error_group(try2J$DATA1_OT$OTpred,try2J$DATA1_OT$Y)
table(try2J$DATA1_OT$OTpred,try2J$DATA1_OT$Y)
try1J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3),
prep_choice = "M", norm = 1, which.DB = 2)
error_group(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
table(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
error_group(try2J$DATA1_OT$OTpred,try2J$DATA1_OT$Y)
error_group = function(REF,Z,ord = TRUE){
if ((is.null(levels(REF)))|(is.null(levels(Z)))){
stop("REF and Z must be factors")
} else {}
if (length(levels(REF))>length(levels(Z))){
stop("The number of levels for Z must be greater than the number of levels of REF")
} else {}
cc = try_group(Z,REF,ordin = ord)
error_g = vector(length = nrow(cc[[1]]))
for (k in 1:nrow(cc[[1]])){
Zbis = as.character(Z)
for (j in 1:ncol(cc[[1]])){
Zbis[Zbis %in% cc[[2]][[cc[[1]][k,j]]]] = levels(REF)[j]
}
Zbis = as.factor(Zbis)
error_g[k] = 100 - round(sum(diag(table(REF,Zbis)))*100/sum(table(REF,Zbis)),1)
error_combi    = data.frame(combi = row.names(cc[[1]]),error_rate= error_g)
error_combi    = error_combi[sort.list(error_combi[,2]),]
}
return(error_combi)
}
levels(try1J$DATA2_OT$OTpred)
levels(try1J$DATA2_OT$Z)
levels(try1J$DATA2_OT$Otpred)
levels(try1J$DATA2_OT$OTpred)
error_group(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
error_group = function(REF,Z,ord = TRUE){
if ((is.null(levels(REF)))|(is.null(levels(Z)))){
stop("REF and Z must be factors")
} else {}
if (length(levels(REF))>length(levels(Z))){
stop("The number of levels for Z must be greater than the number of levels of REF")
} else {}
cc = try_group(Z,REF,ordin = ord)
error_g = vector(length = nrow(cc[[1]]))
for (k in 1:nrow(cc[[1]])){
Zbis = as.character(Z)
for (j in 1:ncol(cc[[1]])){
Zbis[Zbis %in% cc[[2]][[cc[[1]][k,j]]]] = levels(REF)[j]
}
Zbis = as.factor(Zbis)
error_g[k] = 100 - round(sum(diag(table(REF,Zbis)))*100/sum(table(REF,Zbis)),1)
error_combi    = data.frame(combi = row.names(cc[[1]]),error_rate= error_g)
error_combi    = error_combi[sort.list(error_combi[,2]),]
}
return(error_combi)
}
error_group(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
table(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
error_group(try1J$DATA2_OT$OTpred,try1J$DATA2_OT$Y)
try1J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3),
prep_choice = "M", norm = 1)
error_group(try1J$DATA2_OT$OTpred,try1J$DATA2_OT$Y)
levels(try1J$DATA2_OT$OTpred)
summary(try1J$DATA2_OT)
summary(try1J)
OT_joint = function(datab, index_DB_Y_Z = 1:3, nominal = NULL, ordinal = NULL,logic = NULL, prep_choice = "E",infoFAMD = 80, percent_c = 1.0, maxrelax = 0.0,
lambda_reg = 0.0, norm = 1, prox_dist = 1, aggregate_tol = 1, which.DB = 3){
if (prep_choice =="FAMD"){
stop("The FAMD option can not be used here, because continuous quantitative covariates are not allowed here")
} else {}
cat("---------------------------------------","\n")
cat("OT JOINT PROCEDURE in progress ..."     ,"\n")
cat("---------------------------------------","\n")
cat("Type                  = ", ifelse((maxrelax == 0)&(lambda_reg == 0),"JOINT","R-JOINT"),"\n")
cat("Distance              = ", ifelse(norm == 0,"Hamming",ifelse(norm == 1,"Manhattan",ifelse(norm == 2,"Euclidean","Gower"))),"\n")
cat("Percent closest       = ", 100.0*percent_c, "%","\n")
cat("Relaxation term       = ", ifelse(maxrelax == 0,"NO","YES"),"\n")
cat("Regularization weight = ", lambda_reg  ,"\n")
cat("Aggregation tolerance = ", aggregate_tol,"\n")
cat("IMPUTE ?              = ", ifelse(which.DB == 1,"1st DB",ifelse(which.DB == 2,"2nd DB","Both DBs")),"\n")
cat("---------------------------------------","\n")
if (!(which.DB %in% 1:3)){
stop("Invalid value for the which.DB option")
} else {}
if (infoFAMD > 100){
stop("Invalid value for the infoFAMD option")
} else {}
if (percent_c > 100){
stop("Invalid value for the percent related to the definition of a significant neighborood")
} else {}
tstart = Sys.time()
dataB = transfo_dist(datab,index_DB_Y_Z = index_DB_Y_Z,quanti = NULL, nominal = nominal, ordinal = ordinal,
logic = logic, prep_choice = prep_choice, info = infoFAMD)
inst = proxim_dist(dataB, norme = norm, prox = prox_dist)
# Local redefinitions of parameters of  the instance
nA      = inst$nA;
nB      = inst$nB;
A       = 1:nA;
B       = 1:nB;
Y       = inst$Y;
Z       = inst$Z;
indY    = inst$indY;
indZ    = inst$indZ;
Xobserv = inst$Xobserv;
Yobserv = inst$Yobserv;
Zobserv = inst$Zobserv;
# prof    = do.call(paste0,unique(inst$Xobserv))
prof    = as.data.frame(unique(inst$Xobserv))
ID_prof = paste(rep("P",nrow(prof)),1:nrow(prof),sep="_")
# Create a model for the optimal transport of individuals
# modelA = Model(with_optimizer(Gurobi.Optimizer,LogToConsole=0,Method=2,Crossover=0));#ClpSolver(LogLevel=0));
# modelB = Model(with_optimizer(Gurobi.Optimizer,LogToConsole=0,Method=2,Crossover=0));#Model(with_optimizer(Clp.Optimizer,LogLevel=0));
###########################################################################
# Compute data for aggregation of the individuals
###########################################################################
# println("... aggregating individuals")
indXA = inst$indXA; indXB = inst$indXB;
nbX = length(indXA);
# compute the neighbors of the covariates for regularization
Xvalues = unique(Xobserv)
# norme = 1
if (norm == 1){
dist_X  = proxy::dist(Xvalues,Xvalues, method = "manhattan")
} else if (norm == 2){
dist_X  = proxy::dist(Xvalues,Xvalues, method = "euclidean")
} else if (norm == 0){
if (nrow(dataB[,4:ncol(dataB)])== nrow(na.omit(dataB[,4:ncol(dataB)]))){
dist_X  = rdist::cdist(Xvalues,Xvalues, metric = "hamming")
} else {
dist_X  = ham(Xvalues,Xvalues)
}
} else if (norm == 3){
dist_X  = StatMatch::gower.dist(Xvalues,Xvalues)
}
voisins_X = dist_X <= aggregate_tol
# println("... computing costs")
C = avg_dist_closest(inst, percent_closest = percent_c)[1];
###########################################################################
# Compute the estimators that appear in the model
###########################################################################
estim_XA = estim_XB = estim_XA_YA =  estim_XB_ZB = list()
for (x in 1:nbX){
estim_XA[[x]] = length(indXA[[x]])/nA
estim_XB[[x]] = length(indXB[[x]])/nB
}
for (x in 1:nbX){
estim_XA_YA[[x]] = estim_XB_ZB[[x]] = numeric(0)
for (y in Y){
estim_XA_YA[[x]][y] = length(indXA[[x]][Yobserv[indXA[[x]]] == y])/nA
}
for (z in Z){
estim_XB_ZB[[x]][z] = length(indXB[[x]][Zobserv[indXB[[x]] + nA] == z])/nB
}
}
Cf <- function(y,z) {
C$Davg[y,z]
}
estim_XBf <- function(x) {
estim_XB[[x]]
}
voisin = function(x1){lambda_reg *(1/length(voisins_X[x1,]))}
ind_voisins = list()
for (x1 in 1:nrow(voisins_X)){
ind_voisins[[x1]] = which(voisins_X[x1,])
}
###########################################################################
# Basic part of the model
###########################################################################
if (which.DB %in% c(1,3)){
# COMPLETE Z IN DATABASE A
result <-  MIPModel() %>%
# DEFINE VARIABLES ----------------------------------------------------------------------
# gammaA[x,y,z]: joint probability of X=x, Y=y and Z=z in base A
ompr::add_variable(gammaA[x,y,z]       , x = 1:nbX, y = Y, z= Z, type = "continuous") %>%
ompr::add_variable(errorA_XY[x,y]      , x = 1:nbX, y = Y,       type = "continuous") %>%
ompr::add_variable(abserrorA_XY[x,y]   , x = 1:nbX, y = Y,       type = "continuous") %>%
ompr::add_variable(errorA_XZ[x,z]      , x = 1:nbX, z = Z,       type = "continuous") %>%
ompr::add_variable(abserrorA_XZ[x,z]   , x = 1:nbX, z = Z,       type = "continuous") %>%
# REGULARIZATION ---------------------------------------------------------------------------------
ompr::add_variable(reg_absA[x1,x2,y,z] , x1= 1:nbX, x2= 1:nbX, y=Y, z= Z, type = "continuous") %>%
# OBJECTIVE ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ompr::set_objective(sum_expr(Cf(y,z) * gammaA[x,y,z], y = Y, z = Z, x = 1:nbX) + sum_expr(voisin(x1)*reg_absA[x1,x2,y,z], x1 = 1:nbX, x2 = ind_voisins[[x1]],y=Y,z= Z), "min") %>%
# CONSTRAINTS ----------------------------------------------------------------------------------------------------
ompr::add_constraint(sum_expr(gammaA[x,y,z], z = Z) - errorA_XY[x,y] == estim_XA_YA[[x]][y] , x = 1:nbX,y =Y) %>%
ompr::add_constraint(estim_XBf(x)*sum_expr(gammaA[x,y,z],y = Y)  - estim_XBf(x)*errorA_XZ[x,z]== estim_XB_ZB[[x]][z] * estim_XA[[x]] , x = 1:nbX, z = Z) %>%
ompr::add_constraint( errorA_XY[x,y] <= abserrorA_XY[x,y], x = 1:nbX,y =Y) %>%
ompr::add_constraint(-errorA_XY[x,y] <= abserrorA_XY[x,y], x = 1:nbX,y =Y) %>%
ompr::add_constraint(sum_expr(abserrorA_XY[x,y], x = 1:nbX, y = Y)<= maxrelax/2.0) %>%
ompr::add_constraint(sum_expr(errorA_XY[x,y]   , x = 1:nbX, y = Y) == 0.0) %>%
ompr::add_constraint( errorA_XZ[x,z] <= abserrorA_XZ[x,z], x = 1:nbX, z =Z) %>%
ompr::add_constraint(-errorA_XZ[x,z] <= abserrorA_XZ[x,z], x = 1:nbX, z =Z) %>%
ompr::add_constraint(sum_expr(abserrorA_XZ[x,z], x = 1:nbX, z = Z)<= maxrelax/2.0) %>%
ompr::add_constraint(sum_expr(errorA_XZ[x,z]   , x = 1:nbX, z = Z)<= maxrelax/2.0) %>%
# SOLUTION -------------------------------------------------------
ompr::solve_model(with_ROI(solver = "glpk"))
solution  = ompr::get_solution(result, gammaA[x,y,z])
gammaA_val= array(solution$value,dim = c(nbX,length(Y),length(Z)))
#------------ END OPTIMIZATION STEP ------------------------------
### Compute the resulting estimators for the distributions of Z conditional to X and Y in base A
estimatorZA = 1/length(Z) * array(rep(1,nbX*length(Y)*length(Z)),dim = c(nbX,length(Y),length(Z)))
for (x in 1:nbX){
for (y in Y){
proba_c_mA = apply(gammaA_val,c(1,2),sum)[x,y]
if (proba_c_mA > 1.0e-6){
estimatorZA[x,y,] = 1/proba_c_mA * gammaA_val[x,y,];
} else {}
}
}
row.names(estimatorZA) =  ID_prof
colnames(estimatorZA)  = as.character(levels(dataB[,2]))
### Deduce the individual distributions of probability for each individual
probaZindivA = matrix(0,nA,length(Z))
for (x in 1:nbX){
for (i in indXA[[x]]){
probaZindivA[i,] = estimatorZA[x,Yobserv[i],]
}
}
# Transport the probability that maximizes frequency
predZA = numeric(0)
for (i in A){
predZA = c(predZA,which.max(probaZindivA[i,]))
}
DATA1_OT         = dataB[dataB[,1] == unique(dataB[,1])[1],]
DATA1_OT$OTpred  = as.factor(plyr::mapvalues(predZA,from = sort(unique(predZA)), to = levels(dataB[,3])[sort(unique(predZA))]))
if (is.ordered(dataB[,3])){
DATA1_OT$OTpred = as.ordered(DATA1_OT$OTpred)
} else {}
} else {}
if (which.DB %in% c(2,3)){
# COMPLETE Y IN DATABASE B
result <-  ompr::MIPModel() %>%
# DEFINE VARIABLES ----------------------------------------------------------------------
# gammaA[x,y,z]: joint probability of X=x, Y=y and Z=z in base A
ompr::add_variable(gammaB[x,y,z]    , x = 1:nbX, y = Y, z= Z, type = "continuous") %>%
ompr::add_variable(errorB_XY[x,y]   , x = 1:nbX, y = Y,       type = "continuous") %>%
ompr::add_variable(abserrorB_XY[x,y], x = 1:nbX, y = Y,       type = "continuous") %>%
ompr::add_variable(errorB_XZ[x,z]   , x = 1:nbX,        z = Z,type = "continuous") %>%
ompr::add_variable(abserrorB_XZ[x,z], x = 1:nbX,        z = Z,type = "continuous") %>%
# REGULARIZATION ----------------------------------------------------------------------------
ompr::add_variable(reg_absB[x1, x2,y,z],x1=1:nbX, x2=1:nbX,y=Y,z= Z, type = "continuous") %>%
# OBJECTIVE ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ompr::set_objective(sum_expr(Cf(y,z) * gammaB[x,y,z],y = Y,z=Z, x = 1:nbX)  + sum_expr(voisin(x1)*reg_absB[x1,x2,y,z],x1=1:nbX, x2= ind_voisins[[x1]],y=Y,z= Z), "min")  %>%
# CONSTRAINTS ----------------------------------------------------------------------------------------------------
ompr::add_constraint(sum_expr(gammaB[x,y,z], y = Y) -errorB_XZ[x,z]  == estim_XB_ZB[[x]][z] , x = 1:nbX, z = Z) %>%
ompr::add_constraint(estim_XA[[x]]*sum_expr(gammaB[x,y,z] ,z = Z) - estim_XA[[x]] * errorB_XY[x,y] == estim_XA_YA[[x]][y] * estim_XB[[x]] , x = 1:nbX, y = Y) %>%
ompr::add_constraint( errorB_XY[x,y] <= abserrorB_XY[x,y], x = 1:nbX,y =Y) %>%
ompr::add_constraint(-errorB_XY[x,y] <= abserrorB_XY[x,y], x = 1:nbX,y =Y) %>%
ompr::add_constraint(sum_expr(abserrorB_XY[x,y], x = 1:nbX, y = Y)<= maxrelax/2.0) %>%
ompr::add_constraint(sum_expr(errorB_XY[x,y]   , x = 1:nbX, y = Y) == 0.0) %>%
ompr::add_constraint( errorB_XZ[x,z] <= abserrorB_XZ[x,z], x = 1:nbX,z =Z) %>%
ompr::add_constraint(-errorB_XZ[x,z] <= abserrorB_XZ[x,z], x = 1:nbX,z =Z) %>%
ompr::add_constraint(sum_expr(abserrorB_XZ[x,z], x = 1:nbX, z = Z)<= maxrelax/2.0) %>%
ompr::add_constraint(sum_expr(errorB_XZ[x,z]   , x = 1:nbX, z = Z)<= maxrelax/2.0) %>%
# SOLUTION -------------------------------------------------------
ompr::solve_model(with_ROI(solver = "glpk"))
solution  = get_solution(result, gammaB[x,y,z])
gammaB_val= array(solution$value,dim = c(nbX,length(Y),length(Z)))
#------------ END OPTIMIZATION STEP ------------------------------
### compute the resulting estimators for the distributions of Y conditional to X and Z in base B
estimatorYB = 1/length(Y) * array(rep(1,nbX*length(Y)*length(Z)),dim = c(nbX,length(Z),length(Y)))
for (x in 1:nbX){
for (z in Z){
proba_c_mB = apply(gammaB_val,c(1,3),sum)[x,z]
if (proba_c_mB > 1.0e-6){
estimatorYB[x,z,] = 1/proba_c_mB * gammaB_val[x,,z];
} else {}
}
}
row.names(estimatorYB) = ID_prof
colnames(estimatorYB)  = as.character(levels(dataB[,3]))
### Deduce the individual distributions of probability for each individual
probaZindivA = matrix(0,nA,length(Z))
probaYindivB = matrix(0,nB,length(Y))
for (x in 1:nbX){
for (i in indXB[[x]]){
probaYindivB[i,] = estimatorYB[x,Zobserv[i+nA],]
}
}
### Transport the Ylity that maximizes frequency
predYB = numeric(0)
for (j in B){
predYB = c(predYB,which.max(probaYindivB[j,]))
}
# Display the solution
# println("Solution of the joint probability transport");
# println("Distance cost = ", sum(C[y,z] * (gammaA_val[x,y,z]+gammaB_val[x,y,z]) for y in Y, z in Z, x in 1:nbX));
# println("Regularization cost = ", lambda_reg * value(regterm));
DATA2_OT         = dataB[dataB[,1] == unique(dataB[,1])[2],]
DATA2_OT$OTpred  = as.factor(plyr::mapvalues(predYB,from = sort(unique(predYB)), to = levels(dataB[,2])[sort(unique(predYB))]))
if (is.ordered(dataB[,2])){
DATA2_OT$OTpred = as.ordered(DATA2_OT$OTpred)
} else {}
} else {}
if (which.DB == 1){
GAMMA_B            = NULL
estimatorYB        = NULL
DATA2_OT           = NULL
GAMMA_A            = apply(gammaA_val,c(2,3),sum)
colnames(GAMMA_A)  = levels(dataB[,3])
row.names(GAMMA_A) = levels(dataB[,2])
} else if (which.DB == 2){
GAMMA_A            = NULL
estimatorZA        = NULL
DATA1_OT           = NULL
GAMMA_B            = apply(gammaB_val,c(2,3),sum)
colnames(GAMMA_B)  = levels(dataB[,3])
row.names(GAMMA_B) = levels(dataB[,2])
} else {
GAMMA_A = apply(gammaA_val,c(2,3),sum)
GAMMA_B = apply(gammaB_val,c(2,3),sum)
colnames(GAMMA_A) = colnames(GAMMA_B)   = levels(dataB[,3])
row.names(GAMMA_A) = row.names(GAMMA_B) = levels(dataB[,2])
}
tend = Sys.time()
return(list(TIME_EXE = difftime(tend,tstart),
GAMMA_A = GAMMA_A,
GAMMA_B = GAMMA_B,
profile = data.frame(ID = ID_prof,prof),
estimatorZA = estimatorZA,
estimatorYB = estimatorYB,
DATA1_OT = DATA1_OT,
DATA2_OT = DATA2_OT))
}
try1J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3),
prep_choice = "M", norm = 1)
error_group(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
error_group(try1J$DATA2_OT$OTpred,try1J$DATA2_OT$Y)
summary(try1J)
summary(try1J$DATA2_OT)
summary(try1J$DATA1_OT)
error_group(try1J$DATA1_OT$OTpred,try1J$DATA1_OT$Y)
table(try1J$DATA1_OT$OTpred,try1J$DATA1_OT$Y)
data(tab_test)
tab_test2 = tab_test[c(1:70,5001:5070),1:5]
try1J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3),
prep_choice = "M", norm = 1)
try1J[[1]]
head(tab_test2)
data(tab_test)
tab_test2 = tab_test[c(1:75,5001:5075),1:5]
try1J = OT_joint(tab_test2, nominal = c(1,4:5), ordinal = c(2,3),
prep_choice = "M", norm = 1)
error_group(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
table(try1J$DATA2_OT$Z,try1J$DATA2_OT$OTpred)
error_group(try1J$DATA1_OT$OTpred,try1J$DATA1_OT$Y)
table(try1J$DATA1_OT$OTpred,try1J$DATA1_OT$Y)
library(OTrecod)
library(OTrecod)
?OT_joint
library(OTrecod)
setwd(path)
document()
setwd("C:\\Users\\secr\\Desktop\\OTrecod")
document()
library(OTrecod)
devtools::build_manual(pkg=".")
library(OTrecod)
devtools::build_manual(pkg = ".", path = NULL)
devtools::build_manual(pkg = ".", path = NULL)
devtools::build_manual(pkg = ".", path = NULL)
